# 볼링 게임 점수판
## 진행 방법
* 볼링 게임 점수판 요구사항을 파악한다.
* 요구사항에 대한 구현을 완료한 후 자신의 github 아이디에 해당하는 브랜치에 Pull Request(이하 PR)를 통해 코드 리뷰 요청을 한다.
* 코드 리뷰 피드백에 대한 개선 작업을 하고 다시 PUSH한다.
* 모든 피드백을 완료하면 다음 단계를 도전하고 앞의 과정을 반복한다.

## 온라인 코드 리뷰 과정
* [텍스트와 이미지로 살펴보는 온라인 코드 리뷰 과정](https://github.com/next-step/nextstep-docs/tree/master/codereview)

### step 1. 질문 삭제하기 기능 리팩터링
1. 질문 삭제하기 요구사항
   1. 질문 데이터를 완전히 삭제하는 것이 아니라 데이터의 상태를 삭제 상태(boolean type)로 변경한다.
      1. 데이터의 상태는 원시 값이니깐.. 분리하고 포장해야 하나?
   2. 로그인 사용자와 질문한 사람이 같은 경우 삭제 가능
   3. 답변이 없는 경우(메서드 추출) 삭제가 가능
   4. 질문자와 답변 글의 모든 답변자가 같은 경우 삭제가 가능(메서드 추출)
   5. 질문을 삭제할 때 답변 또한 삭제해야 하며, 답변의 삭제 또한 삭제 상태(delete)를 변경
   6. 질문자와 답변자가 다를 경우 답변을 삭제할 수 없다.
   7. 질문과 답변 삭제 이력에 대한 정보를 DeleteHistory 를 활용해 남긴다.
2. 프로그래밍 요구사항
   1. qna.service.QnaService 의 deleteQuestion() 메서드는 단위 테스트하기 어려운 코드와 단위 테스트가 가능한 코드로 섞여 있다.
   2. 단위 테스트하기 어려운 코드와 단위 테스트 가능한 코드를 분리하고
   3. 테스트 가능한 코드에 대해 단위 테스트를 구현한다.
3. Question, Answer, DeleteHistory 클래스가 맡고 있는 역할과 책임을 최대한 분리하자
4. Question 의 boolean deleted 를 분리하고 포장해서 클래스로 빼내보자.
5. Question 의 List<Answer> 를 @Embeddable 을 사용하여 일급 콜렉션을 사용해보자.
6. List<DeleteHistory> 일급 콜렉션을 사용해보자

#### step 1-1. 질문 삭제하기 기능 리팩토링 (피드백 반영)
1. Answers 에 테스트만을 위한 프로덕션 코드가 존재한다
2. 생성자로 값을 받아서 생성 후에 바로 getDeleteHistories 를 호출하고 있다
   1. getter 이외에 별다른 행위를 하고 있지 않은데 꼭 필요한 녀석일까?
3. DeleteHistories 에는 전부 getter 로 값을 꺼내와서 처리하고 있는데, 메시지를 보내서 DeleteHistory 를 전달 받도록 해보자
4. Answer 클래스에서 메시지를 보내 권한 검증 및 삭제 처리를 해보자
5. 현재 question 과 하위의 각 answer 에게 메시지를 보내서 DeleteHistory 를 받아오도록 해보자
6. 삭제 처리시에 user 검증을 Answer 가 처리하도록 해보자

### step 2. 볼링 점수판(그리기)
0. step 1 피드백 리스트
   1. AbstractEntity 에서 가지고 있는 DeleteHistory 에 대한 생성을 각 엔티티에서 처리해보자
      1. 그리고 생성하는 부분을 정적 팩토리를 메서드를 사용해보자
   2. Question 의 delete 메서드와 관련하여 변수, 인자를 조정해보자!
1. **최종 목표는 볼링 점수를 계산하는 프로그램 구현**
2. 현재 step 의 목표는 **점수 계산을 제외한 볼링 게임 점수판을 구현하는 것**
3. 각 프레임이 스트라이크면 "X", 스페어면 "9|/", 미스면 "8|1"과 같이 출력한다
   1. 스트라이크(strike): 첫 번째 투구에서 모든 핀(10개)을 쓰러트린 상태
   2. 스페어(spare): 두 번째 투구에서 모든 핀(10개)을 쓰러트린 상태
   3. 미스(miss): 프레임의 두 번째 투구에서도 모든 핀이 쓰러지지 않은 상태
   4. 거터(gutter): 핀을 하나도 쓰러트리지 못한 상태. 거터는 "-"로 표시
4. 10 프레임은 스트라이크이거나 스페어면 한 번 더 투구할 수 있다. (10 프레임은 2번 일 수도, 3번 일수도 있다.)
5. 플레이어 이름은 3 글자의 영어를 입력한다.
6. 총 10개의 프레임을 투구할 수 있으며
7. 각 프레임은 한 번 혹은 두 번 투구할 수 있다.
   1. 스트라이크면 한 번, 스트라이크가 아니면 두 번
8. 투구에 대한 값도 원시 값 포장해볼 필요가 있다.
9. 일반 프레임, 마지막 프레임을 구분해서 사용해보자.

### step 3. 볼링 점수판(점수 계산)
0. step 2 피드백 리스트
   1. ReadyTest 에서 여러 개의 assertion 사용 시 assertAll 로 치환해보자
   2. ReadyTest 에서 인터페이스 구현의 다형성을 활용하여 타입을 Status 로 해보자
   3. Strike 는 더 이상 shoot 메서드를 호출 할 수 없기 때문에 지원하지 않는 메서드의 예외는 `UnsupportedOperationException` 을 사용하자
   4. 다수의 Test 코드에서 사용되는 픽스처의 경우 별도 상수 클래스를 사용해볼 수 있다. `ShootScore` 타입으로 사용한다면 상태 검증 테스트에서 중복을 줄일 수 있다.
   5. ResultView 에서 인스턴스 타입 분기를 통해 처리를 하였는데, 각 상태가 자신이 표현할 값을 리턴하도록 처리해본다면 어떨까? 
   6. ResultView 에서 String.format 과 `%-3s` 를 사용할 경우 정렬과 자릿수를 고정 시킬 수 있을 거 같다.
   7. BowlingApplication 에서 `한 메서드에 오직 한 단계의 들여쓰기만 한다.`를 지켜서 1depth 만 사용하도록 변경해보자
   8. BowlingApplication 에서 너무 많은 비지니스 로직이 존재한다.
      1. 컨트롤러에 대한 단위 테스트가 없기 때문에 이번 단계의 메인 로직인 프레임 생성에 대한 검증을 할 수가 없다.
      2. 힌트에 있는 `다음 Frame 을 현재 Frame 외부에서 생성하기 보다 현재 Frame 에서 다음 Frame 을 생성하는 방식으로 구현`을 적용해보자
      3. 다른 방법으론 Frame + 프레임 생성 로직과 PlayerName 을 감싸는 총괄 도메인을 추가해볼 수 있다.
   9. BowlingApplication 에서 findFrameByRound 에서 Frame 타입으로 받아도 되지 않을까? => 
   10. Frame 의 shoot 메서드의 리턴 타입을 Frame 으로 해서 설계를 해보자
   11. (Optional) 현재는 10개의 프레임을 모두 만들어두고 사용하고 있다. 매 투구시에 Round 정보가 그래서 필요하다.
       1. 최초 1 프레임만 생성한 후에 투구 이후에 프레임이 종료되었을 경우 다음 프레임을 추가한다면
       2. frames 의 맨 마지막 프레임만 가져와서 놀면 되기 때문에 round 정보가 필요 없다.
1. **사용자 1명의 볼링 게임 점수를 관리할 수 있는 프로그램을 구현**
2. **객체지향 5원칙(SOLID)을 지키면서 프로그래밍한다.** (복습 차원에서 정리해보자)
   1. SRP (단일책임의 원칙: Single Responsibility Principle)
      1. 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임(변화의 축: axis of change)을 수행하는데 집중되어 있어야 한다.
   2. OCP (개방 폐쇄의 원칙: Open Close Principle)
      1. 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다.
   3. LSP (리스코프 치환의 원칙: The Liskov Substitution Principle)
      1. 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다. 즉, 서브 타입은 언제나 기반 타입과 호환될 수 있어야 한다.
   4. ISP (인터페이스 분리의 원칙: Interface Segregation Principle)
      1. 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
   5. DIP (의존성역전의 원칙: Dependency Inversion Principle)
      1. 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전 원칙이다.
3. Strike, Spare 가 아닌 평범한 투구의 경우는 바로 점수를 계산한다. (다음 프레임을 볼 필요가 없으니깐)
4. Strike 의 경우는 다음 프레임이 끝이 났을 경우에 계산을 한다.
5. Spare 의 경우는 다음 프레임이 FirstShoot 으로 이동했을 경우에 계산을 한다.
6. 투구가 끝났을 경우(Miss, Spare, Strike) 해당 프레임의 Score 클래스를 만든다.
7. 그 이후에 그 다음 프레임에서 shoot 메서드를 호출 할 때마다, 이전 프레임의 Score 클래스를 확인해야 된다.
8. Score 클래스는 이전 프레임의 Score 가 가지고 있던 점수 필드와 Miss, Spare, Strike 에 따른 다음 프레임에서 참조해야 하는 필드 값으로 구성한다.

#### step 3-1. 볼링 점수판(점수 계산) 피드백 반영
1. assertAll 을 사용할 땐 각 assert 구문을 Executable 로 감싸야 함!
2. 현재 BowlingGame 에는 3개의 인스턴스를 가지고 있는데 객체지향 생활 체조 규칙에 맞춰 줄여보는 방식을 생각해보자
3. BowlingGame 에 대한 테스트 코드 작성!
4. Frame 의 구현체들은 shoot 이후에 this 를 반환하는데 nextFrame 이 맞는걸까??
5. 힌트를 참고하여 각 프레임이 점수를 계산해보도록
6. Frame 에서 Score 를 계산해보도록 해보면 ScoreBoard 클래스를 제거할 수 있을 거 같음!
7. (코멘트) Frame 의 Status 로 부터 Score 를 계산하게 하는걸 고민해보자.